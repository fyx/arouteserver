
router id 192.0.2.1;
define rs_as = 64496;

log "/var/log/bird.log" all;
log syslog all;
debug protocols { states, routes, filters, interfaces, events };

timeformat base         iso long;
timeformat log          iso long;
timeformat protocol     iso long;
timeformat route        iso long;

protocol device {};

ipv4 table master4 sorted;




# ---------------------------------------------------------
# RPKI

roa4 table RPKI4;
roa6 table RPKI6;
protocol static {
    roa4 { table RPKI4; };
    route 193.0.0.0/21 max 21 as 3333;
    route 193.0.24.0/22 max 26 as 3333;
    route 193.0.10.0/23 max 23 as 3333;
    route 193.0.12.0/23 max 23 as 3333;
    route 193.0.14.0/23 max 23 as 25152;
    route 193.0.18.0/23 max 23 as 3333;
    route 193.0.20.0/23 max 23 as 3333;
    route 193.0.22.0/23 max 23 as 3333;
    route 193.0.14.0/24 max 24 as 25152;
    route 193.0.24.0/24 max 24 as 3333;
}



# ---------------------------------------------------------
# IRRDB

# AS3333, used_by client AS3333_1
define AS_SET_AS3333_asns = [
	3333
];

define AS_SET_AS3333_prefixes_4 = [
	193.0.0.0/21{21,32}, 	193.0.10.0/23{23,32}, 	193.0.12.0/23{23,32}, 	193.0.18.0/23{23,32},
	193.0.20.0/22{23,32}
];

# AS65551, used_by client AS65551_1
define AS_SET_AS65551_asns = [
	65551
];

# no IPv4 prefixes found for AS65551

# AS10745, used_by client AS10745_1
define AS_SET_AS10745_asns = [
	10745
];

define AS_SET_AS10745_prefixes_4 = [
	192.136.136.0/24{24,32}, 	192.149.252.0/24{24,32}, 	199.43.0.0/24{24,32}
];

# AS-RIPENCC, used_by client AS3333_1
define AS_SET_AS_RIPENCC_asns = [
	2121, 3333, 12654
];

define AS_SET_AS_RIPENCC_prefixes_4 = [
	23.128.24.0/24{24,32}, 	27.50.0.0/22{22,32}, 	39.0.1.0/24{24,32}, 	84.205.64.0/22{24,32},
	84.205.69.0/24{24,32}, 	84.205.70.0/24{24,32}, 	84.205.74.0/23{24,32}, 	84.205.76.0/24{24,32},
	84.205.79.0/24{24,32}, 	84.205.80.0/22{24,32}, 	84.205.85.0/24{24,32}, 	84.205.86.0/24{24,32},
	84.205.88.0/24{24,32}, 	84.205.90.0/23{24,32}, 	84.205.92.0/24{24,32}, 	84.205.95.0/24{24,32},
	93.175.144.0/24{24,32}, 	93.175.146.0/24{24,32}, 	93.175.152.0/23{24,32}, 	93.175.154.0/25{25,32},
	93.175.154.128/28{28,32}, 	103.1.0.0/22{22,32}, 	103.1.4.0/24{24,32}, 	106.0.1.0/24{24,32},
	193.0.0.0/21{21,32}, 	193.0.10.0/23{23,32}, 	193.0.12.0/23{23,32}, 	193.0.18.0/23{23,32},
	193.0.20.0/22{23,32}, 	193.0.24.0/21{21,32}
];





# ---------------------------------------------------------
# COMMON

# Get the 16bit value used to represent a peer with a 32bit ASN.
# Return 0 if no mapping exists for the peer.
function get_16bit_mapped_asn(int asn_32_bit) -> int {
	case asn_32_bit {
		65551: return 64512;
	}
	return 0;
}

# This function returns True if 'net' is a bogon prefix
# or falls within a bogon prefix.
function prefix_is_bogon() -> bool
prefix set bogons_4;
{
	bogons_4 = [
		# Default route
		0.0.0.0/0,

		# IANA - Local Identification
		0.0.0.0/8{8,32},

		# RFC 1918 - Private Use
		10.0.0.0/8{8,32},

		# IANA - Loopback
		127.0.0.0/8{8,32},

		# RFC 3927 - Link Local
		169.254.0.0/16{16,32},

		# RFC 1918 - Private Use
		172.16.0.0/12{12,32},

		# RFC 5737 - TEST-NET-1
		192.0.2.0/24{24,32},

		# RFC 3068 - 6to4 prefix
		192.88.99.0/24{24,32},

		# RFC 1918 - Private Use
		192.168.0.0/16{16,32},

		# RFC 2544 - Network Interconnect Device Benchmark Testing
		198.18.0.0/15{15,32},

		# RFC 5737 - TEST-NET-2
		198.51.100.0/24{24,32},

		# RFC 5737 - TEST-NET-3
		203.0.113.0/24{24,32},

		# RFC 5771 - Multcast (formerly Class D)
		224.0.0.0/3{3,32},

		# RFC 6598 - Shared Address Space
		100.64.0.0/10{10,32}
	];

	if net.type = NET_IP4 then
		if net ~ bogons_4 then return true;
	return false;
}

# This function returns True if 'net' falls within a
# prefix contained in the global blacklist (for example,
# local networks)
function prefix_is_in_global_blacklist() -> bool
prefix set global_blacklist_4;
{
	global_blacklist_4 = [
		# None
		192.0.2.0/24{24,32}
	];

	if net.type = NET_IP4 then
		if net ~ global_blacklist_4 then return true;

	return false;
}

# This function returns True if the length of 'net' prefix
# falls within the range 'min'-'max' (included).
function prefix_len_is_valid (int pref_len_min; int pref_len_max) -> bool {
	if net.len < pref_len_min then return false;
	if net.len > pref_len_max then return false;
	return true;
}

# This function returns True if the AS_PATH contains one or
# more private/reserved ASN.
function as_path_contains_invalid_asn() -> bool
int set invalid_asns;
{
	# http://www.iana.org/assignments/as-numbers/as-numbers.xhtml
	invalid_asns = [
		# 16-bit
		0,			# Reserved. RFC7607
		23456,			# AS_TRANS. RFC6793
		64496..64511,		# Reserved for use in documentation and sample code. RFC5398
		64512..65534,		# Reserved for Private Use. RFC6996
		65535,			# Reserved. RFC7300

		# 32-bit
		65536..65551,		# Reserved for use in documentation and sample code. RFC5398
		65552..131071,		# Reserved.
		4200000000..4294967294, # Reserved for Private Use. [RFC6996]
		4294967295		# Reserved. RFC7300
	];
	return bgp_path ~ invalid_asns;
}


# This function scrubs BGP communities used by the route server
# for signaling purpose toward its clients. (RFC7454, Section 11)
# It must be applied on routes entering the route server.
function scrub_communities_in()
int mapped_16bit_asn;
{
	# origin_not_present_in_as_set
	bgp_community.delete([(64512, 20)]);
	bgp_large_community.delete([(64496, 64512, 20)]);
	bgp_ext_community.delete([(rt, 64512, 20)]);

	# origin_present_in_as_set
	bgp_community.delete([(64512, 21)]);
	bgp_large_community.delete([(64496, 64512, 21)]);
	bgp_ext_community.delete([(rt, 64512, 21)]);

	# prefix_not_present_in_as_set
	bgp_community.delete([(64512, 10)]);
	bgp_large_community.delete([(64496, 64512, 10)]);
	bgp_ext_community.delete([(rt, 64512, 10)]);

	# prefix_present_in_as_set
	bgp_community.delete([(64512, 11)]);
	bgp_large_community.delete([(64496, 64512, 11)]);
	bgp_ext_community.delete([(rt, 64512, 11)]);

	# prefix_validated_via_rpki_roas
	bgp_community.delete([(64512, 31)]);
	bgp_large_community.delete([(64496, 64512, 31)]);
	bgp_ext_community.delete([(rt, 64512, 31)]);

	# route_validated_via_white_list
	bgp_community.delete([(64512, 41)]);
	bgp_large_community.delete([(64496, 64512, 41)]);
	bgp_ext_community.delete([(rt, 64512, 41)]);

	# rpki_bgp_origin_validation_not_performed
	bgp_community.delete([(64512, 50)]);
	bgp_large_community.delete([(64496, 1000, 3)]);
	bgp_ext_community.delete([(rt, 64512, 50)]);

	# reject_cause
	bgp_community.delete([(65520, *)]);
	bgp_large_community.delete([(64496, 65520, *)]);
	bgp_ext_community.delete([(rt, 65520, *)]);

	# reject_cause_map_1
	bgp_large_community.delete([(64496, 1101, 5)]);

	# reject_cause_map_10
	bgp_large_community.delete([(64496, 1101, 3)]);

	# reject_cause_map_12
	bgp_large_community.delete([(64496, 1101, 9)]);

	# reject_cause_map_14
	bgp_large_community.delete([(64496, 1101, 13)]);

	# reject_cause_map_2
	bgp_large_community.delete([(64496, 1101, 3)]);

	# reject_cause_map_5
	bgp_large_community.delete([(64496, 1101, 8)]);

	# reject_cause_map_6
	bgp_large_community.delete([(64496, 1101, 7)]);

	# reject_cause_map_7
	bgp_large_community.delete([(64496, 1101, 4)]);

	# reject_cause_map_8
	bgp_large_community.delete([(64496, 1101, 14)]);

	# reject_cause_map_9
	bgp_large_community.delete([(64496, 1101, 10)]);

	# rpki_bgp_origin_validation_invalid
	bgp_community.delete([(64512, 53)]);
	bgp_large_community.delete([(64496, 1000, 4)]);
	bgp_ext_community.delete([(rt, 64512, 53)]);

	# rpki_bgp_origin_validation_unknown
	bgp_community.delete([(64512, 52)]);
	bgp_large_community.delete([(64496, 1000, 2)]);
	bgp_ext_community.delete([(rt, 64512, 52)]);

	# rpki_bgp_origin_validation_valid
	bgp_community.delete([(64512, 51)]);
	bgp_large_community.delete([(64496, 1000, 1)]);
	bgp_ext_community.delete([(rt, 64512, 51)]);

}

# This function scrubs BGP communities used by clients to instruct
# the route server to perform some actions.
# It must be applied on routes leaving the route server.
function scrub_communities_out()
int mapped_16bit_asn;
{
	# add_noadvertise_to_peer
	bgp_community.delete([(65282, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 65551
	bgp_community.delete([(65282, 64512)]);
	bgp_large_community.delete([(64496, 65282, 1..64511)]);
	bgp_large_community.delete([(64496, 65282, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65282, 1..64511)]);
	bgp_ext_community.delete([(rt, 65282, 131072..4199999999)]);

	# add_noexport_to_peer
	bgp_community.delete([(65281, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 65551
	bgp_community.delete([(65281, 64512)]);
	bgp_large_community.delete([(64496, 65281, 1..64511)]);
	bgp_large_community.delete([(64496, 65281, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65281, 1..64511)]);
	bgp_ext_community.delete([(rt, 65281, 131072..4199999999)]);

	# announce_to_peer
	bgp_community.delete([(64496, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 65551
	bgp_community.delete([(64496, 64512)]);
	bgp_large_community.delete([(64496, 1, 1..64511)]);
	bgp_large_community.delete([(64496, 1, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 64496, 1..64511)]);
	bgp_ext_community.delete([(rt, 64496, 131072..4199999999)]);

	# do_not_announce_to_any
	bgp_community.delete([(0, 64496)]);
	bgp_large_community.delete([(64496, 0, 0)]);
	bgp_ext_community.delete([(rt, 0, 64496)]);

	# do_not_announce_to_peer
	bgp_community.delete([(0, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 65551
	bgp_community.delete([(0, 64512)]);
	bgp_large_community.delete([(64496, 0, 1..64511)]);
	bgp_large_community.delete([(64496, 0, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 0, 1..64511)]);
	bgp_ext_community.delete([(rt, 0, 131072..4199999999)]);

	# prepend_once_to_any
	bgp_community.delete([(65501, 64496)]);
	bgp_large_community.delete([(64496, 101, 0)]);
	bgp_ext_community.delete([(rt, 65501, 64496)]);

	# prepend_once_to_peer
	bgp_community.delete([(65511, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 65551
	bgp_community.delete([(65511, 64512)]);
	bgp_large_community.delete([(64496, 101, 1..64511)]);
	bgp_large_community.delete([(64496, 101, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65511, 1..64511)]);
	bgp_ext_community.delete([(rt, 65511, 131072..4199999999)]);

	# prepend_thrice_to_any
	bgp_community.delete([(65503, 64496)]);
	bgp_large_community.delete([(64496, 103, 0)]);
	bgp_ext_community.delete([(rt, 65503, 64496)]);

	# prepend_thrice_to_peer
	bgp_community.delete([(65513, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 65551
	bgp_community.delete([(65513, 64512)]);
	bgp_large_community.delete([(64496, 103, 1..64511)]);
	bgp_large_community.delete([(64496, 103, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65513, 1..64511)]);
	bgp_ext_community.delete([(rt, 65513, 131072..4199999999)]);

	# prepend_twice_to_any
	bgp_community.delete([(65502, 64496)]);
	bgp_large_community.delete([(64496, 102, 0)]);
	bgp_ext_community.delete([(rt, 65502, 64496)]);

	# prepend_twice_to_peer
	bgp_community.delete([(65512, 1..64511)]);
	# 64512 is the 16bit_mapped_asn for 65551
	bgp_community.delete([(65512, 64512)]);
	bgp_large_community.delete([(64496, 102, 1..64511)]);
	bgp_large_community.delete([(64496, 102, 131072..4199999999)]);
	bgp_ext_community.delete([(rt, 65512, 1..64511)]);
	bgp_ext_community.delete([(rt, 65512, 131072..4199999999)]);

	# reject_cause
	bgp_community.delete([(65520, *)]);
	bgp_large_community.delete([(64496, 65520, *)]);
	bgp_ext_community.delete([(rt, 65520, *)]);

	# reject_cause_map_1
	bgp_large_community.delete([(64496, 1101, 5)]);

	# reject_cause_map_10
	bgp_large_community.delete([(64496, 1101, 3)]);

	# reject_cause_map_12
	bgp_large_community.delete([(64496, 1101, 9)]);

	# reject_cause_map_14
	bgp_large_community.delete([(64496, 1101, 13)]);

	# reject_cause_map_2
	bgp_large_community.delete([(64496, 1101, 3)]);

	# reject_cause_map_5
	bgp_large_community.delete([(64496, 1101, 8)]);

	# reject_cause_map_6
	bgp_large_community.delete([(64496, 1101, 7)]);

	# reject_cause_map_7
	bgp_large_community.delete([(64496, 1101, 4)]);

	# reject_cause_map_8
	bgp_large_community.delete([(64496, 1101, 14)]);

	# reject_cause_map_9
	bgp_large_community.delete([(64496, 1101, 10)]);

	# rpki_bgp_origin_validation_invalid
	bgp_community.delete([(64512, 53)]);
	bgp_large_community.delete([(64496, 1000, 4)]);
	bgp_ext_community.delete([(rt, 64512, 53)]);

	# rpki_bgp_origin_validation_unknown
	bgp_community.delete([(64512, 52)]);
	bgp_large_community.delete([(64496, 1000, 2)]);
	bgp_ext_community.delete([(rt, 64512, 52)]);

	# rpki_bgp_origin_validation_valid
	bgp_community.delete([(64512, 51)]);
	bgp_large_community.delete([(64496, 1000, 1)]);
	bgp_ext_community.delete([(rt, 64512, 51)]);

}

# This function verifies if the route is tagged with one of
# the blackhole filtering communities.
function is_blackhole_filtering_request() -> bool
int mapped_16bit_asn;
{
	if net.type = NET_IP4 then {
	}
	return false;
}

# This function must be applied to outgoing routes.
# It applies the blackhole filtering policy to the current route.
function apply_blackhole_filtering_policy() {
	if net.type = NET_IP4 then {

	reject "blackhole filtering requested but no IPv4 policy given - REJECTING ", net;

	}
}

# This function verifies if the current route can be announced to
# the given client on the basis of the attached control BGP
# communities.
function route_can_be_announced_to(int peer_as; ip client_ip; string client_id) -> bool
int client_rtt;
int mapped_16bit_asn;
{
	# do_not_announce_to_peer
	if peer_as <= 65535 then {
		if (0, peer_as) ~ bgp_community then
			return false;
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (0, mapped_16bit_asn) ~ bgp_community then
				return false;
		}
	}
	if (64496, 0, peer_as) ~ bgp_large_community then
		return false;
	if (rt, 0, peer_as) ~ bgp_ext_community then
		return false;

	# announce_to_peer
	if peer_as <= 65535 then {
		if (64496, peer_as) ~ bgp_community then
			return true;
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (64496, mapped_16bit_asn) ~ bgp_community then
				return true;
		}
	}
	if (64496, 1, peer_as) ~ bgp_large_community then
		return true;
	if (rt, 64496, peer_as) ~ bgp_ext_community then
		return true;

	# do_not_announce_to_any
	if (0, 64496) ~ bgp_community then
		return false;
	if (64496, 0, 0) ~ bgp_large_community then
		return false;
	if (rt, 0, 64496) ~ bgp_ext_community then
		return false;

	return true;
}

# This function prepends the left-most ASN <times> times.
function do_prepend(int times) {
	case times {
		1: bgp_path.prepend(bgp_path.first);
		2: bgp_path.prepend(bgp_path.first); bgp_path.prepend(bgp_path.first);
		3: bgp_path.prepend(bgp_path.first); bgp_path.prepend(bgp_path.first); bgp_path.prepend(bgp_path.first);
	}
}

# This function verifies if the current route matches one of the
# control communities in charge of prepending client's ASN.
function apply_prepend(int peer_as; ip client_ip) -> bool
int client_rtt;
int mapped_16bit_asn;
{
	# prepend_once_to_peer
	if peer_as <= 65535 then {
		if (65511, peer_as) ~ bgp_community then
			{ do_prepend(1); return true; }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65511, mapped_16bit_asn) ~ bgp_community then
				{ do_prepend(1); return true; }
		}
	}
	if (64496, 101, peer_as) ~ bgp_large_community then
		{ do_prepend(1); return true; }
	if (rt, 65511, peer_as) ~ bgp_ext_community then
		{ do_prepend(1); return true; }

	# prepend_twice_to_peer
	if peer_as <= 65535 then {
		if (65512, peer_as) ~ bgp_community then
			{ do_prepend(2); return true; }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65512, mapped_16bit_asn) ~ bgp_community then
				{ do_prepend(2); return true; }
		}
	}
	if (64496, 102, peer_as) ~ bgp_large_community then
		{ do_prepend(2); return true; }
	if (rt, 65512, peer_as) ~ bgp_ext_community then
		{ do_prepend(2); return true; }

	# prepend_thrice_to_peer
	if peer_as <= 65535 then {
		if (65513, peer_as) ~ bgp_community then
			{ do_prepend(3); return true; }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65513, mapped_16bit_asn) ~ bgp_community then
				{ do_prepend(3); return true; }
		}
	}
	if (64496, 103, peer_as) ~ bgp_large_community then
		{ do_prepend(3); return true; }
	if (rt, 65513, peer_as) ~ bgp_ext_community then
		{ do_prepend(3); return true; }



	# prepend_once_to_any
	if (65501, 64496) ~ bgp_community then
		{ do_prepend(1); return true; }
	if (64496, 101, 0) ~ bgp_large_community then
		{ do_prepend(1); return true; }
	if (rt, 65501, 64496) ~ bgp_ext_community then
		{ do_prepend(1); return true; }

	# prepend_twice_to_any
	if (65502, 64496) ~ bgp_community then
		{ do_prepend(2); return true; }
	if (64496, 102, 0) ~ bgp_large_community then
		{ do_prepend(2); return true; }
	if (rt, 65502, 64496) ~ bgp_ext_community then
		{ do_prepend(2); return true; }

	# prepend_thrice_to_any
	if (65503, 64496) ~ bgp_community then
		{ do_prepend(3); return true; }
	if (64496, 103, 0) ~ bgp_large_community then
		{ do_prepend(3); return true; }
	if (rt, 65503, 64496) ~ bgp_ext_community then
		{ do_prepend(3); return true; }


	return true;
}

# This function adds the BGP communities used to
# keep track of RPKI validation state.
# RFC8097 extended communities are used here.
function add_rpki_community(string comm_name) {
	# RFC8097 BGP communities
	if comm_name = "valid" then {
		bgp_ext_community.add((unknown 0x4300, 0, 0));
	}
	if comm_name = "unknown" then {
		bgp_ext_community.add((unknown 0x4300, 0, 1));
	}
	if comm_name = "invalid" then {
		bgp_ext_community.add((unknown 0x4300, 0, 2));
	}

	# rpki_bgp_origin_validation_valid communities
	if comm_name = "valid" then {
		bgp_community.add((64512, 51));
		bgp_large_community.add((64496, 1000, 1));
		bgp_ext_community.add((rt, 64512, 51));

	}
	# rpki_bgp_origin_validation_unknown communities
	if comm_name = "unknown" then {
		bgp_community.add((64512, 52));
		bgp_large_community.add((64496, 1000, 2));
		bgp_ext_community.add((rt, 64512, 52));

	}
	# rpki_bgp_origin_validation_invalid communities
	if comm_name = "invalid" then {
		bgp_community.add((64512, 53));
		bgp_large_community.add((64496, 1000, 4));
		bgp_ext_community.add((rt, 64512, 53));

	}
}

# This functions performs RPKI validation of the current
# route and adds the informative communities.
function perform_rpki_validation () {
	if net.type = NET_IP4 then {
		case roa_check(RPKI4) {
			ROA_VALID: add_rpki_community("valid");
			ROA_UNKNOWN: add_rpki_community("unknown");
			ROA_INVALID: add_rpki_community("invalid");
		}
	} else {
		case roa_check(RPKI6) {
			ROA_VALID: add_rpki_community("valid");
			ROA_UNKNOWN: add_rpki_community("unknown");
			ROA_INVALID: add_rpki_community("invalid");
		}
	}
}

# This function returns True if the route is INVALID.
function route_is_rpki_invalid () -> bool {
	return (unknown 0x4300, 0, 2) ~ bgp_ext_community;
}

# This function returns True if RPKI INVALID routes
# should be announced to clients.
function announce_rpki_invalid_to_client(int client_asn; ip client_ip; string client_id) -> bool {
	return false;
}

# This function adds NO_EXPORT and/or NO_ADVERTISE
# well-known communities.
function add_noexport_noadvertise(int peer_as)
int mapped_16bit_asn;
{
	# add_noexport_to_peer
	
	if peer_as <= 65535 then {
		if (65281, peer_as) ~ bgp_community then
			{ bgp_community.add((65535, 65281)); }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65281, mapped_16bit_asn) ~ bgp_community then
				{ bgp_community.add((65535, 65281)); }
		}
	}
	if (64496, 65281, peer_as) ~ bgp_large_community then
		{ bgp_community.add((65535, 65281)); }
	if (rt, 65281, peer_as) ~ bgp_ext_community then
		{ bgp_community.add((65535, 65281)); }

	# add_noadvertise_to_peer
	
	if peer_as <= 65535 then {
		if (65282, peer_as) ~ bgp_community then
			{ bgp_community.add((65535, 65282)); }
	} else {
		mapped_16bit_asn = get_16bit_mapped_asn(peer_as);
		if mapped_16bit_asn > 0 then {
			if (65282, mapped_16bit_asn) ~ bgp_community then
				{ bgp_community.add((65535, 65282)); }
		}
	}
	if (64496, 65282, peer_as) ~ bgp_large_community then
		{ bgp_community.add((65535, 65282)); }
	if (rt, 65282, peer_as) ~ bgp_ext_community then
		{ bgp_community.add((65535, 65282)); }

}

function tag_and_reject(int cause; int announcing_asn)
int dyn_val;
int mapped_16bit_asn;
{
	# 0: the route must be treated as discarded
	dyn_val = 0;
	bgp_community.add((65520, dyn_val));
		bgp_large_community.add((64496, 65520, dyn_val));
		bgp_ext_community.add((rt, 65520, dyn_val));


	# cause: the reject cause
	dyn_val = cause;

	# add the generic community from reject_cause
	bgp_community.add((65520, dyn_val));
		bgp_large_community.add((64496, 65520, dyn_val));
		bgp_ext_community.add((rt, 65520, dyn_val));


	# communities from reject_cause_map
	case cause {
		# 1 = Invalid AS_PATH length
		1 : bgp_large_community.add((64496, 1101, 5));
		# 2 = Prefix is bogon
		2 : bgp_large_community.add((64496, 1101, 3));
		# 5 = Invalid NEXT_HOP
		5 : bgp_large_community.add((64496, 1101, 8));
		# 6 = Invalid left-most ASN
		6 : bgp_large_community.add((64496, 1101, 7));
		# 7 = Invalid ASN in AS_PATH
		7 : bgp_large_community.add((64496, 1101, 4));
		# 8 = Transit-free ASN in AS_PATH
		8 : bgp_large_community.add((64496, 1101, 14));
		# 9 = Origin ASN not in IRRDB AS-SETs
		9 : bgp_large_community.add((64496, 1101, 10));
		# 10 = IPv6 prefix not in global unicast space
		10 : bgp_large_community.add((64496, 1101, 3));
		# 12 = Prefix not in IRRDB AS-SETs
		12 : bgp_large_community.add((64496, 1101, 9));
		# 14 = RPKI INVALID route
		14 : bgp_large_community.add((64496, 1101, 13));
	}


	bgp_local_pref = 1;
}

function honor_graceful_shutdown() {
	if (65535, 0) ~ bgp_community then {
		bgp_local_pref = 0;
	}
}

function prevent_graceful_shutdown() {
	if (65535, 0) ~ bgp_community then {
		bgp_community.delete([(65535, 0)]);
	}
}


# This function verifies if there is such a ROA for the
# current route's origin ASN to validate the announced prefix.
function prefix_in_rpki_roas_as_route_objects() -> bool {
	if net.type = NET_IP4 then {
		case roa_check(RPKI4) {
			ROA_VALID: return true;
		}
	} else {
		case roa_check(RPKI6) {
			ROA_VALID: return true;
		}
	}
	return false;
}




# ---------------------------------------------------------
# MEMBERS


# AS-SET for AS10745_1
function origin_as_is_in_AS10745_1_as_set() -> bool {
	if bgp_path.last ~ AS_SET_AS10745_asns then
		return true;
	return false;
}

# R-SET for AS10745_1
function prefix_is_in_AS10745_1_as_set() -> bool {
    if net.type = NET_IP4 then
        if net ~ AS_SET_AS10745_prefixes_4 then
            return true;
    return false;
}

function next_hop_is_valid_for_AS10745_1() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS10745_1
	if bgp_next_hop = 192.0.2.22 then return true;
	return false;
}


function verify_AS10745_1_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS10745_1_as_set();
	prefix_ok = prefix_is_in_AS10745_1_as_set();

	if !origin_ok then {
		bgp_community.add((64512, 20));
		bgp_large_community.add((64496, 64512, 20));
		bgp_ext_community.add((rt, 64512, 20));

	}
	if origin_ok then {
		bgp_community.add((64512, 21));
		bgp_large_community.add((64496, 64512, 21));
		bgp_ext_community.add((rt, 64512, 21));

	}
	if !prefix_ok then {
		bgp_community.add((64512, 10));
		bgp_large_community.add((64496, 64512, 10));
		bgp_ext_community.add((rt, 64512, 10));

	}
	if prefix_ok then {
		bgp_community.add((64512, 11));
		bgp_large_community.add((64496, 64512, 11));
		bgp_ext_community.add((rt, 64512, 11));

	}

	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		bgp_community.add((64512, 31));
		bgp_large_community.add((64496, 64512, 31));
		bgp_ext_community.add((rt, 64512, 31));

		validated = true;
	}




	if !validated && !origin_ok then {
		tag_and_reject(9, 10745); reject "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 10745); reject "prefix not in client's r_set - REJECTING ", net;
	}
}

filter receive_from_AS10745_1 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 10745); reject "source != RTS_BGP - REJECTING ", net; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 10745); reject "AFI not enabled for this peer - REJECTING ", net; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS10745_1() then
		{ tag_and_reject(5, 10745); reject "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; }

	# AS_PATH: length
	if bgp_path.len > 32 then
		{ tag_and_reject(1, 10745); reject "AS_PATH len [", bgp_path.len ,"] longer than 32 - REJECTING ", net; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 10745 then
		{ tag_and_reject(6, 10745); reject "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 10745); reject "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [174, 701, 1299, 2914, 3257, 3320, 3356, 5511, 6453, 6461, 6762, 6830, 7018, 12956] then
		{ tag_and_reject(8, 10745); reject "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [46, 92, 174, 278, 680, 714, 1257, 1273, 1299, 1734, 1955, 2119, 2152, 2527, 2603, 2698, 2914, 3257, 3265, 3292, 3320, 3454, 3491, 3630, 3754, 5391, 5432, 5511, 6079, 6405, 6730, 6805, 6830, 6908, 7843, 8075, 8365, 8455, 8607, 8943, 8989, 9908, 9928, 10000, 10013, 11164, 11260, 11290, 11670, 12353, 12389, 12491, 12822, 12926, 13030, 13032, 13631, 14295, 14430, 15305, 15692, 16509, 17012, 17390, 18520, 18914, 20115, 20161, 21396, 21647, 23888, 23961, 24115, 24282, 24800, 25215, 26068, 27947, 28398, 29169, 29695, 30600, 30781, 30967, 30983, 31764, 32598, 32840, 33983, 34108, 34209, 34587, 35836, 35900, 36165, 36459, 36914, 37271, 37529, 38145, 38623, 38713, 39326, 39651, 40063, 42083, 43470, 46450, 46887, 47377, 47584, 48237, 48265, 48408, 49127, 49695, 50576, 50670, 50919, 51530, 51630, 52662, 52990, 53859, 54295, 54574, 56028, 57142, 57433, 57866, 58401, 58768, 59282, 60412, 60449, 60757, 61368, 61525, 62164, 62350, 62467, 62567, 62623, 63126, 63290, 63739, 131398, 131996, 132563, 132829, 132996, 133647, 134022, 135706, 135848, 136106, 136874, 137207, 137610, 138023, 138228, 138368, 138769, 138953, 139667, 140287, 141134, 141411, 141856, 141892, 142164, 142369, 146846, 146958, 149251, 149391, 149587, 149663, 149826, 150242, 151403, 151538, 151633, 151765, 152300, 198250, 199737, 199956, 200558, 201978, 202256, 202351, 202561, 202793, 204482, 206003, 206275, 207195, 207484, 208425, 208753, 209165, 209310, 209810, 210030, 212285, 212512, 212686, 212706, 213202, 215436, 215617, 216047, 216265, 262191, 263127, 263258, 263686, 265630, 266917, 267214, 267561, 267823, 269367, 269906, 270544, 271053, 271172, 272018, 272097, 272124, 273101, 273608, 327732, 328959, 329210, 329253, 393573, 393684, 393731, 394837, 396304, 396477, 397736, 398203, 398296, 398427] then
	{ tag_and_reject(15, 10745); reject "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 10745); reject "prefix is in global blacklist - REJECTING ", net; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 10745); reject "prefix is bogon - REJECTING ", net; }

	# IRRdb checks
	verify_AS10745_1_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((64512, 50));
		bgp_large_community.add((64496, 1000, 3));
		bgp_ext_community.add((rt, 64512, 50));

		accept "blackhole filtering request from AS10745_1 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 10745); reject "RPKI, route is INVALID - REJECTING ", net; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 10745); reject "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS10745_1
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;
	if (64496, 65520, 0) ~ bgp_large_community then
		reject;
	if (rt, 65520, 0) ~ bgp_ext_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(10745, 192.0.2.22, "AS10745_1") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS10745_1";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(10745, 192.0.2.22, "AS10745_1") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS10745_1";

	apply_prepend(10745, 192.0.2.22);


	add_noexport_noadvertise(10745);

	scrub_communities_out();



	accept;
}

protocol bgp AS10745_1 {

	local as 64496;
	neighbor 192.0.2.22 as 10745;
	rs client;

	local role rs_server;

	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;


	secondary;

	receive limit 121 action disable;


	import table on;

	import keep filtered on;

	import filter receive_from_AS10745_1;
	export filter announce_to_AS10745_1;
	# ---------------------------------------
	};

		}


# AS-SET for AS3333_1
function origin_as_is_in_AS3333_1_as_set() -> bool {
	if bgp_path.last ~ AS_SET_AS3333_asns then
		return true;
	if bgp_path.last ~ AS_SET_AS_RIPENCC_asns then
		return true;
	return false;
}

# R-SET for AS3333_1
function prefix_is_in_AS3333_1_as_set() -> bool {
    if net.type = NET_IP4 then
        if net ~ AS_SET_AS3333_prefixes_4 then
            return true;
    if net.type = NET_IP4 then
        if net ~ AS_SET_AS_RIPENCC_prefixes_4 then
            return true;
    return false;
}

function next_hop_is_valid_for_AS3333_1() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS3333_1
	if bgp_next_hop = 192.0.2.11 then return true;
	return false;
}


function verify_AS3333_1_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS3333_1_as_set();
	prefix_ok = prefix_is_in_AS3333_1_as_set();

	if !origin_ok then {
		bgp_community.add((64512, 20));
		bgp_large_community.add((64496, 64512, 20));
		bgp_ext_community.add((rt, 64512, 20));

	}
	if origin_ok then {
		bgp_community.add((64512, 21));
		bgp_large_community.add((64496, 64512, 21));
		bgp_ext_community.add((rt, 64512, 21));

	}
	if !prefix_ok then {
		bgp_community.add((64512, 10));
		bgp_large_community.add((64496, 64512, 10));
		bgp_ext_community.add((rt, 64512, 10));

	}
	if prefix_ok then {
		bgp_community.add((64512, 11));
		bgp_large_community.add((64496, 64512, 11));
		bgp_ext_community.add((rt, 64512, 11));

	}

	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		bgp_community.add((64512, 31));
		bgp_large_community.add((64496, 64512, 31));
		bgp_ext_community.add((rt, 64512, 31));

		validated = true;
	}




	if !validated && !origin_ok then {
		tag_and_reject(9, 3333); reject "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 3333); reject "prefix not in client's r_set - REJECTING ", net;
	}
}

filter receive_from_AS3333_1 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 3333); reject "source != RTS_BGP - REJECTING ", net; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 3333); reject "AFI not enabled for this peer - REJECTING ", net; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS3333_1() then
		{ tag_and_reject(5, 3333); reject "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; }

	# AS_PATH: length
	if bgp_path.len > 32 then
		{ tag_and_reject(1, 3333); reject "AS_PATH len [", bgp_path.len ,"] longer than 32 - REJECTING ", net; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 3333 then
		{ tag_and_reject(6, 3333); reject "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 3333); reject "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [174, 701, 1299, 2914, 3257, 3320, 3356, 5511, 6453, 6461, 6762, 6830, 7018, 12956] then
		{ tag_and_reject(8, 3333); reject "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [46, 92, 174, 278, 680, 714, 1257, 1273, 1299, 1734, 1955, 2119, 2152, 2527, 2603, 2698, 2914, 3257, 3265, 3292, 3320, 3454, 3491, 3630, 3754, 5391, 5432, 5511, 6079, 6405, 6730, 6805, 6830, 6908, 7843, 8075, 8365, 8455, 8607, 8943, 8989, 9908, 9928, 10000, 10013, 11164, 11260, 11290, 11670, 12353, 12389, 12491, 12822, 12926, 13030, 13032, 13631, 14295, 14430, 15305, 15692, 16509, 17012, 17390, 18520, 18914, 20115, 20161, 21396, 21647, 23888, 23961, 24115, 24282, 24800, 25215, 26068, 27947, 28398, 29169, 29695, 30600, 30781, 30967, 30983, 31764, 32598, 32840, 33983, 34108, 34209, 34587, 35836, 35900, 36165, 36459, 36914, 37271, 37529, 38145, 38623, 38713, 39326, 39651, 40063, 42083, 43470, 46450, 46887, 47377, 47584, 48237, 48265, 48408, 49127, 49695, 50576, 50670, 50919, 51530, 51630, 52662, 52990, 53859, 54295, 54574, 56028, 57142, 57433, 57866, 58401, 58768, 59282, 60412, 60449, 60757, 61368, 61525, 62164, 62350, 62467, 62567, 62623, 63126, 63290, 63739, 131398, 131996, 132563, 132829, 132996, 133647, 134022, 135706, 135848, 136106, 136874, 137207, 137610, 138023, 138228, 138368, 138769, 138953, 139667, 140287, 141134, 141411, 141856, 141892, 142164, 142369, 146846, 146958, 149251, 149391, 149587, 149663, 149826, 150242, 151403, 151538, 151633, 151765, 152300, 198250, 199737, 199956, 200558, 201978, 202256, 202351, 202561, 202793, 204482, 206003, 206275, 207195, 207484, 208425, 208753, 209165, 209310, 209810, 210030, 212285, 212512, 212686, 212706, 213202, 215436, 215617, 216047, 216265, 262191, 263127, 263258, 263686, 265630, 266917, 267214, 267561, 267823, 269367, 269906, 270544, 271053, 271172, 272018, 272097, 272124, 273101, 273608, 327732, 328959, 329210, 329253, 393573, 393684, 393731, 394837, 396304, 396477, 397736, 398203, 398296, 398427] then
	{ tag_and_reject(15, 3333); reject "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 3333); reject "prefix is in global blacklist - REJECTING ", net; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 3333); reject "prefix is bogon - REJECTING ", net; }

	# IRRdb checks
	verify_AS3333_1_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((64512, 50));
		bgp_large_community.add((64496, 1000, 3));
		bgp_ext_community.add((rt, 64512, 50));

		accept "blackhole filtering request from AS3333_1 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 3333); reject "RPKI, route is INVALID - REJECTING ", net; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 3333); reject "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS3333_1
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;
	if (64496, 65520, 0) ~ bgp_large_community then
		reject;
	if (rt, 65520, 0) ~ bgp_ext_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(3333, 192.0.2.11, "AS3333_1") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS3333_1";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(3333, 192.0.2.11, "AS3333_1") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS3333_1";

	apply_prepend(3333, 192.0.2.11);


	add_noexport_noadvertise(3333);

	scrub_communities_out();



	accept;
}

protocol bgp AS3333_1 {

	local as 64496;
	neighbor 192.0.2.11 as 3333;
	rs client;

	local role rs_server;

	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;


	secondary;

	receive limit 150 action disable;


	import table on;

	import keep filtered on;

	import filter receive_from_AS3333_1;
	export filter announce_to_AS3333_1;
	# ---------------------------------------
	};

		}


# AS-SET for AS65551_1
function origin_as_is_in_AS65551_1_as_set() -> bool {
	if bgp_path.last ~ AS_SET_AS65551_asns then
		return true;
	return false;
}

# R-SET for AS65551_1
function prefix_is_in_AS65551_1_as_set() -> bool {
	# AS-SET AS65551 referenced but empty.
    return false;
}

function next_hop_is_valid_for_AS65551_1() -> bool
{
	# Checks if NEXT_HOP is one of those allowed for routes announced by AS65551_1
	if bgp_next_hop = 192.0.2.33 then return true;
	return false;
}


function verify_AS65551_1_irrdb()
bool origin_ok;
bool prefix_ok;
bool validated;
{
	origin_ok = false;
	prefix_ok = false;
	validated = false;

	origin_ok = origin_as_is_in_AS65551_1_as_set();
	prefix_ok = prefix_is_in_AS65551_1_as_set();

	if !origin_ok then {
		bgp_community.add((64512, 20));
		bgp_large_community.add((64496, 64512, 20));
		bgp_ext_community.add((rt, 64512, 20));

	}
	if origin_ok then {
		bgp_community.add((64512, 21));
		bgp_large_community.add((64496, 64512, 21));
		bgp_ext_community.add((rt, 64512, 21));

	}
	if !prefix_ok then {
		bgp_community.add((64512, 10));
		bgp_large_community.add((64496, 64512, 10));
		bgp_ext_community.add((rt, 64512, 10));

	}
	if prefix_ok then {
		bgp_community.add((64512, 11));
		bgp_large_community.add((64496, 64512, 11));
		bgp_ext_community.add((rt, 64512, 11));

	}

	# Origin ASN is valid, prefix is not: check if a RPKI ROAs exists.
	if origin_ok && prefix_in_rpki_roas_as_route_objects() then {
		bgp_community.add((64512, 31));
		bgp_large_community.add((64496, 64512, 31));
		bgp_ext_community.add((rt, 64512, 31));

		validated = true;
	}




	if !validated && !origin_ok then {
		tag_and_reject(9, 65551); reject "origin ASN [", bgp_path.last, "] not in allowed as-sets - REJECTING ", net;
	}
	if !validated && !prefix_ok then {
		tag_and_reject(12, 65551); reject "prefix not in client's r_set - REJECTING ", net;
	}
}

filter receive_from_AS65551_1 {
	if !(source = RTS_BGP ) then
		{ tag_and_reject(65535, 65551); reject "source != RTS_BGP - REJECTING ", net; }

	if !(net.type = NET_IP4) then
		{ tag_and_reject(65535, 65551); reject "AFI not enabled for this peer - REJECTING ", net; }


	scrub_communities_in();


	# NEXT_HOP
	if !next_hop_is_valid_for_AS65551_1() then
		{ tag_and_reject(5, 65551); reject "NEXT_HOP [", bgp_next_hop, "] not allowed - REJECTING ", net; }

	# AS_PATH: length
	if bgp_path.len > 32 then
		{ tag_and_reject(1, 65551); reject "AS_PATH len [", bgp_path.len ,"] longer than 32 - REJECTING ", net; }

	# AS_PATH: left-most ASN
	if bgp_path.first != 65551 then
		{ tag_and_reject(6, 65551); reject "invalid left-most ASN [", bgp_path.first, "] - REJECTING ", net; }

	# AS_PATH: invalid ASNs
	if as_path_contains_invalid_asn() then
		{ tag_and_reject(7, 65551); reject "AS_PATH [", bgp_path ,"] contains invalid ASN - REJECTING ", net; }

	# AS_PATH: transit-free ASNs
	if bgp_path ~ [174, 701, 1299, 2914, 3257, 3320, 3356, 5511, 6453, 6461, 6762, 6830, 7018, 12956] then
		{ tag_and_reject(8, 65551); reject "AS_PATH [", bgp_path ,"] contains transit-free ASN - REJECTING ", net; }

	# AS_PATH: never via route-servers ASNs
	if bgp_path ~ [46, 92, 174, 278, 680, 714, 1257, 1273, 1299, 1734, 1955, 2119, 2152, 2527, 2603, 2698, 2914, 3257, 3265, 3292, 3320, 3454, 3491, 3630, 3754, 5391, 5432, 5511, 6079, 6405, 6730, 6805, 6830, 6908, 7843, 8075, 8365, 8455, 8607, 8943, 8989, 9908, 9928, 10000, 10013, 11164, 11260, 11290, 11670, 12353, 12389, 12491, 12822, 12926, 13030, 13032, 13631, 14295, 14430, 15305, 15692, 16509, 17012, 17390, 18520, 18914, 20115, 20161, 21396, 21647, 23888, 23961, 24115, 24282, 24800, 25215, 26068, 27947, 28398, 29169, 29695, 30600, 30781, 30967, 30983, 31764, 32598, 32840, 33983, 34108, 34209, 34587, 35836, 35900, 36165, 36459, 36914, 37271, 37529, 38145, 38623, 38713, 39326, 39651, 40063, 42083, 43470, 46450, 46887, 47377, 47584, 48237, 48265, 48408, 49127, 49695, 50576, 50670, 50919, 51530, 51630, 52662, 52990, 53859, 54295, 54574, 56028, 57142, 57433, 57866, 58401, 58768, 59282, 60412, 60449, 60757, 61368, 61525, 62164, 62350, 62467, 62567, 62623, 63126, 63290, 63739, 131398, 131996, 132563, 132829, 132996, 133647, 134022, 135706, 135848, 136106, 136874, 137207, 137610, 138023, 138228, 138368, 138769, 138953, 139667, 140287, 141134, 141411, 141856, 141892, 142164, 142369, 146846, 146958, 149251, 149391, 149587, 149663, 149826, 150242, 151403, 151538, 151633, 151765, 152300, 198250, 199737, 199956, 200558, 201978, 202256, 202351, 202561, 202793, 204482, 206003, 206275, 207195, 207484, 208425, 208753, 209165, 209310, 209810, 210030, 212285, 212512, 212686, 212706, 213202, 215436, 215617, 216047, 216265, 262191, 263127, 263258, 263686, 265630, 266917, 267214, 267561, 267823, 269367, 269906, 270544, 271053, 271172, 272018, 272097, 272124, 273101, 273608, 327732, 328959, 329210, 329253, 393573, 393684, 393731, 394837, 396304, 396477, 397736, 398203, 398296, 398427] then
	{ tag_and_reject(15, 65551); reject "AS_PATH [", bgp_path ,"] contains never via route-servers ASN - REJECTING ", net; }


	# Prefix: global blacklist
	if prefix_is_in_global_blacklist() then
		{ tag_and_reject(3, 65551); reject "prefix is in global blacklist - REJECTING ", net; }


	# Prefix: bogon
	if prefix_is_bogon() then
		{ tag_and_reject(2, 65551); reject "prefix is bogon - REJECTING ", net; }

	# IRRdb checks
	verify_AS65551_1_irrdb();

	# Blackhole request?
	if is_blackhole_filtering_request() then {
		# rpki_bgp_origin_validation_not_performed communities
		bgp_community.add((64512, 50));
		bgp_large_community.add((64496, 1000, 3));
		bgp_ext_community.add((rt, 64512, 50));

		accept "blackhole filtering request from AS65551_1 - ACCEPTING ", net;
	} else {
		perform_rpki_validation();

		if route_is_rpki_invalid() then
			{ tag_and_reject(14, 65551); reject "RPKI, route is INVALID - REJECTING ", net; }

		# Prefix: length
		if !prefix_len_is_valid(8, 24) then
			{ tag_and_reject(13, 65551); reject "prefix len [", net.len, "] not in 8-24 - REJECTING ", net; }

		honor_graceful_shutdown();
	}


	accept;
}

filter announce_to_AS65551_1
int mapped_16bit_asn;
{


	if (65520, 0) ~ bgp_community then
		reject;
	if (64496, 65520, 0) ~ bgp_large_community then
		reject;
	if (rt, 65520, 0) ~ bgp_ext_community then
		reject;


	# Blackhole request?
	if is_blackhole_filtering_request() then {
		apply_blackhole_filtering_policy();
	} else {
		# RPKI: do not announce INVALID to clients
		if route_is_rpki_invalid() then {
			if !announce_rpki_invalid_to_client(65551, 192.0.2.33, "AS65551_1") then
				reject "route is INVALID - NOT ANNOUNCING ", net, " TO AS65551_1";
		}
	}

	# BGP control communities
	if !route_can_be_announced_to(65551, 192.0.2.33, "AS65551_1") then
		reject "route didn't pass control communities checks - NOT ANNOUNCING ", net, " TO AS65551_1";

	apply_prepend(65551, 192.0.2.33);


	add_noexport_noadvertise(65551);

	scrub_communities_out();



	accept;
}

protocol bgp AS65551_1 {

	local as 64496;
	neighbor 192.0.2.33 as 65551;
	rs client;

	local role rs_server;

	passive on;
	ttl security off;

	interpret communities off;

	# ---------------------------------------
	ipv4 {
	table master4;


	secondary;

	receive limit 170000 action disable;


	import table on;

	import keep filtered on;

	import filter receive_from_AS65551_1;
	export filter announce_to_AS65551_1;
	# ---------------------------------------
	};

		}



